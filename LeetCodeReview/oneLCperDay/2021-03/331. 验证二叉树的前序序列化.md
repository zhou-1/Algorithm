## 331. 验证二叉树的前序序列化 【中等】      
[栈]      
https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/         

### 方法一: 栈     
栈的思路是「自底向上」的想法。下面要结合本题是「前序遍历」这个重要特点。    
我们知道「前序遍历」是按照「根节点-左子树-右子树」的顺序遍历的，只有当根节点的所有左子树遍历完成之后，才会遍历右子树。对于本题的输入，我们可以先判断「左子树」是否有效的，然后再判断「右子树」是否有效的，最后判断「根节点-左子树-右子树」是否为有效的。这个思路类似于递归，而把递归改写成循环时，就会使用「栈」，这就是本题使用「栈」的原因。      
当一个节点不是叶子节点的时候，那么它必定至少有一个孩子非空！有两种情况：     
1.两个孩子都非"#"（空）；   
2.一个孩子为"#"（空），另一个孩子非"#"（空）；     
为了兼容这两个情况，我们想出了本题的一个重磅级的技巧：把有效的叶子节点使用 "#" 代替。比如把 4## 替换成 # 。此时，非叶子节点会变成叶子节点！      
具体操作流程示例如下：     
如输入： "9,3,4,#,#,1,#,#,2,#,6,#,#" ，当遇到 x # # 的时候，就把它变为 #。     
模拟一遍过程：     
9,3,4,#,# => 9,3,#，继续    
9,3,#,1,#,# => 9,3,#,# => 9,# ，继续    
9,#2,#,6,#,# => 9,#,2,#,# => 9,#,# => #，结束    
这个操作流程完美结合了「栈」和「前序遍历」的特性，完美！     
```
class Solution(object):
    def isValidSerialization(self, preorder):
        stack = []
        for node in preorder.split(','):
            stack.append(node)
            while len(stack) >= 3 and stack[-1] == stack[-2] == '#' and stack[-3] != '#':
                stack.pop(), stack.pop(), stack.pop()
                stack.append('#')
        return len(stack) == 1 and stack.pop() == '#'

```


