## 456. 132模式 【中等】    
[栈]     
https://leetcode-cn.com/problems/132-pattern/    

### 方法一：枚举 3     
枚举 3 是容易想到并且也是最容易实现的。由于 3 是模式中的最大值，并且其出现在 1 和 2 的中间，因此我们只需要从左到右枚举 3 的下标 j，那么：     
由于 1 是模式中的最小值，因此我们在枚举 j 的同时，维护数组 a 中左侧元素 a[0..j−1] 的最小值，即为 1 对应的元素 a[i]。需要注意的是，只有 a[i]<a[j] 时，a[i] 才能作为 1 对应的元素；    
由于 2 是模式中的次小值，因此我们可以使用一个有序集合（例如平衡树）维护数组 a 中右侧元素 a[j+1..n−1] 中的所有值。当我们确定了 a[i] 和 a[j] 之后，只需要在有序集合中查询严格比 a[i] 大的那个最小的元素，即为 a[k]。需要注意的是，只有 a[k]<a[j] 时，a[k] 才能作为 3 对应的元素。     
```
public boolean find132pattern(int[] nums) {
        //即第二个数aj最大，第三个数ak次大，第一个数ai最小
        
        //得到nums size
        int n = nums.length;
        if (n < 3) {
            return false;
        }

        // 左侧最小值
        int leftMin = nums[0];
        // 右侧所有元素
        TreeMap<Integer, Integer> rightAll = new TreeMap<Integer, Integer>();

        //从第3个元素开始遍历，把元素及其频率放入treemap中
        for (int k = 2; k < n; ++k) {
            rightAll.put(nums[k], rightAll.getOrDefault(nums[k], 0) + 1);
        }

        // 遍历第二个元素
        for (int j = 1; j < n - 1; ++j) {
            if (leftMin < nums[j]) {
                Integer next = rightAll.ceilingKey(leftMin + 1);
                if (next != null && next < nums[j]) {
                    return true;
                }
            }

            //否则的话，更新最小的元素
            leftMin = Math.min(leftMin, nums[j]);
            rightAll.put(nums[j + 1], rightAll.get(nums[j + 1]) - 1);
            if (rightAll.get(nums[j + 1]) == 0) {
                rightAll.remove(nums[j + 1]);
            }
        }

        return false;

}
```

