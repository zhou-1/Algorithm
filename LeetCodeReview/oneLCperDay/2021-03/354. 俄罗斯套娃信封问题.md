## 354. 俄罗斯套娃信封问题 【困难】     
[二分查找，动态规划]      
https://leetcode-cn.com/problems/russian-doll-envelopes/       

### 思路及想法    
今天的题目要求信封套信封最多套多少层，并且套的过程中信封长与宽不能旋转；长或者宽相等的时候，两个信封不能套在一起。      
可以抽象成：     
题意：找出二维数组的一个排列，使得其中有最长的单调递增子序列（两个维度都递增）。      
「遇事不决先排序」，排序能让数据变成有序的，降低了混乱程度。      

### 方法一：两个维度都递增的排序      
其实就是求最长递增子序列的一个变种，先把信封按照宽度进行非降序排序，如果宽度一样，在按照高度进行降序排序，然后再求数组高度的最长递增子序列即可。      
```
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        if (envelopes == null || envelopes.length == 0) {
            return 0;
        }

        //先根据第一个元素大小来排位置，然后根据第二个元素大小来排位置
        Arrays.sort(envelopes, (int[] arr1, int[] arr2) -> {
            if (arr1[0] == arr2[0])
                return arr2[1] - arr1[1];
            else
                return arr1[0] - arr2[0];
        });

        return lengthOfLIS(envelopes);
    }

    public int lengthOfLIS(int[][] nums) {
        int[] dp = new int[nums.length];
        int max = 0;

        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i][1] > nums[j][1])
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            max = Math.max(max, dp[i]);
        }
        
        return max + 1;
    }

}
```


### 方法二：第一维递增，第二维递减的排序    








