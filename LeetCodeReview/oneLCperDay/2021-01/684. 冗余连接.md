## 684. 冗余连接 【中等】       
[树，并查集，图]       

在本问题中, 树指的是一个连通且无环的无向图。     
输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。    
结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。    
返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。     

示例 1：     
输入: [[1,2], [1,3], [2,3]]     
输出: [2,3]    
解释: 给定的无向图为:    
  1    
 / \    
2 - 3    

示例 2：     
输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]     
输出: [1,4]    
解释: 给定的无向图为:    
5 - 1 - 2    
    |   |    
    4 - 3    
     
注意:     
输入的二维数组大小在 3 到 1000。      
二维数组中的整数在1到N之间，其中N是输入数组的大小。     

更新(2017-09-26):     
我们已经重新检查了问题描述及测试用例，明确图是无向 图。对于有向图详见冗余连接II。对于造成任何不便，我们深感歉意。    

### 并查集      
在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有 N−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N。             
树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。              
可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。          
如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。         
如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。            
并查集是一种树型的数据结构，用于处理一些不相交集合（DisjointDisjoint SetsSets）的合并及查询问题。常常在使用中以森林来表示。      
合并（UnionUnion）：把两个不相交的集合合并为一个集合    
查询（FindFind）：查询两个元素是否在同一个集合中       
时间复杂度：O(NlogN)，其中 N 是图中的节点个数。需要遍历图中的 N 条边，对于每条边，需要对两个节点查找祖先，如果两个节点的祖先不同则需要进行合并，需要进行 2 次查找和最多 1 次合并。一共需要进行 2N 次查找和最多 N 次合并，因此总时间复杂度是 O(2NlogN)=O(NlogN)。这里的并查集使用了路径压缩，但是没有使用按秩合并，最坏情况下的时间复杂度是 O(NlogN)，平均情况下的时间复杂度依然是 O(Nα(N))，其中 α 为阿克曼函数的反函数，α(N) 可以认为是一个很小的常数。     
空间复杂度：O(N)，其中 N 是图中的节点个数。使用数组 parent 记录每个节点的祖先。      
```
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        int nodesCount = edges.length;
        int[] parent = new int[nodesCount + 1];

        for(int i = 1; i <= nodesCount; i++) {
            parent[i] = i;
        }

        for(int i = 0; i < nodesCount; i++) {
            int[] edge = edges[i];
            int node1 = edge[0], node2 = edge[1];
            if(find(parent, node1) != find(parent, node2)) {
                union(parent, node1, node2);
            } else {
                return edge;
            }
        }

        return new int[0];
    }

    private void union(int[] parent, int index1, int index2) {
        parent[find(parent, index1)] = find(parent, index2);
    }

    private int find(int[] parent, int index) {
        if(parent[index] != index) {
            parent[index] = find(parent, parent[index]);
        }

        return parent[index];
    }
}
```





























