## 264. 丑数 II 【中等】     
[堆，数学，动态规划]     
https://leetcode-cn.com/problems/ugly-number-ii/     

### 最小堆   
要得到从小到大的第 n 个丑数，可以使用最小堆实现。    
初始时堆为空。首先将最小的丑数 1 加入堆。    
每次取出堆顶元素 x，则 x 是堆中最小的丑数，由于 2x,3x,5x 也是丑数，因此将 2x,3x,5x 加入堆。    
上述做法会导致堆中出现重复元素的情况。为了避免重复元素，可以使用哈希集合去重，避免相同元素多次加入堆。      
在排除重复元素的情况下，第 n 次从最小堆中取出的元素即为第 n 个丑数。     

```
public int nthUglyNumber(int n) {
        int[] factors = {2,3,5};

        HashSet<Long> seen = new HashSet<> ();
        PriorityQueue<Long> heap = new PriorityQueue<> ();
        seen.add(1L);
        heap.offer(1L);

        int ugly = 0;
        for(int i = 0; i < n; i++) {
            //最小堆的堆顶元素
            long cur = heap.poll(); 
            ugly = (int)cur;
            for(int factor : factors) {
                long next = cur * factor;
                if(seen.add(next)) {
                    heap.offer(next);
                }
            }
        }

        return ugly;
}
```
