## 5. Longest Palindromic Substring    
Given a string s, return the longest palindromic substring in s.

Example 1:     
Input: s = "babad"    
Output: "bab"      
Note: "aba" is also a valid answer.     

Example 2:    
Input: s = "cbbd"    
Output: "bb"     

Example 3:    
Input: s = "a"    
Output: "a"     

Example 4:      
Input: s = "ac"    
Output: "a"     

Constraints:     
1 <= s.length <= 1000     
s consist of only digits and English letters (lower-case and/or upper-case)      

## Answer    
### 1.Dynamic Programming     
If we already knew that "bab" is a palindrome, it is obvious that "ababa" must be a palindrome since the two left and right end letters are the same.     
Define p(i,j) = true (if substring si...sj is a palindrome) OR false (otherwise)     
p(i,j) = p(i+1, j-1) and si == sj. Base cases are: p(i,j)=true, p(i, i+1)=(si==si+1)     
Time complexity: O(n^2)    
Space complexity: O(n^2)    
```
public String longestPalindrome(String s) {
        int n = s.length();
        String res = "";
        
        boolean[][]dp = new boolean[n][n];
        
        if (s == null || s.length() < 1) return "";
        
        for(int i = n-1; i >= 0; --i){
            for(int j = i; j < n; ++j){
                //dp(i, j) is true when s(i) equals to s(j) and s(i+1 ... j-1) is a palindromic substring. 
                dp[i][j] = (s.charAt(i) == s.charAt(j)) && (j - i < 3 || dp[i+1][j-1]);
                // chars at i and j should match
                // if window is less than 3, just end chars should match
                // if window is >= 3, substring (i+1, j-1) should be palindrome too
                
                if(dp[i][j] && (res == null || j-i+1 >res.length()) ){
                    res = s.substring(i, j+1);
                }
                
            }
        }
        
        return res;
}
```

### 2.Expand around center    


