# 106. Construct Binary Tree from Inorder and Postorder Traversal [medium]     
Given inorder and postorder traversal of a tree, construct the binary tree.     

Note:   
You may assume that duplicates do not exist in the tree.    

For example, given    
inorder = [9,3,15,20,7]    
postorder = [9,15,7,20,3]    

Return the following binary tree:       
    3   
   / \   
  9  20   
    /  \   
   15   7   


## Solution     
inorder: left, root, right     
postorder: left, right, root     
The the basic idea is to take the last element in postorder array as the root, find the position of the root in the inorder array.    
Then locate the range for left sub-tree and right sub-tree and do recursion. Use a HashMap to record the index of root in the inorder array.   

### My recursive Java code 
HashMap, key: value of the element in inorder, value: index of that element.       

is - start index for inorder array    
ie - end index for inorder array     
ps - start index for postorder array     
pe - end index for postorder array      

Remember :      
InOrder is (left subtree) node (right subtree)     
PostOrder is (left subtree)(right subtree) (node)     
From post order array we get the root which will be at index pe     
while from in order we can get the number of children in the left subtree ie. ri-is     

Time complexity: O(n)     
Space complexity: O(n)     

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        // check for extreme case
        if(inorder == null || postorder == null || inorder.length != postorder.length){
            return null;
        }
        // create a HashMap for value and index
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < inorder.length; i++ ){
            map.put(inorder[i], i);
        }
        
        return helper(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1, map);
        
    }
    
    // helper function for get the root
    private TreeNode helper(int[] inorder, int is, int ie, int[] postorder, int ps, int pe, 
                                 HashMap<Integer,Integer> map){
        // check for extreme condition
        if(is > ie || ps > pe){
            return null;
        }
        
        // get current root
        TreeNode root = new TreeNode(postorder[pe]);
        
        // get index of the element
        int ri = map.get(postorder[pe]);
        
        TreeNode leftchild = helper(inorder, is, ri-1, postorder, ps, ps+ri-is-1, map);
	    TreeNode rightchild = helper(inorder,ri+1, ie, postorder, ps+ri-is, pe-1, map);
	    
        root.left = leftchild;
	    root.right = rightchild;
	    
        return root;
        
        
    }
    
}
```


